1. FFmpeg with openCL

ffmpeg -init_hw_device opencl=ocl:,device_type=gpu

ffmpeg -init_hw_device vaapi=va:/dev/dri/renderD128 -init_hw_device opencl=ocl@va -loglevel 99

ffmpeg -init_hw_device vaapi=va:/dev/dri/renderD128 -init_hw_device opencl=ocl@va -hwaccel vaapi -hwaccel_device va -hwaccel_output_format vaapi -i INPUT -filter_hw_device ocl -filter_complex '[0:v]hwmap,tonemap_opencl=t=bt2020:tonemap=linear:format=p010[x1]; [x1]hwmap=derive_device=vaapi:reverse=1' -c:v hevc_vaapi -profile 2 OUTPUT

./ffmpeg_g -y -init_hw_device vaapi=va:/dev/dri/renderD128 -init_hw_device opencl=ocl@va -hwaccel vaapi -hwaccel_device va -hwaccel_output_format vaapi -i ../../../Videos/skyfall2-trailer.mp4 -f image2 -r 1 -i overlays/%d.png -an -filter_hw_device ocl -filter_complex '[1:v]format=yuva420p,hwupload[x2]; [0:v]scale_vaapi=1280:720:yuv420p,hwmap[x1]; [x1][x2]overlay_opencl=0:0,program_opencl=test.cl:rotate_image,unsharp_opencl=lx=17:ly=17:la=5,hwmap=derive_device=vaapi:reverse=1,scale_vaapi=1280:720:nv12' -c:v h264_vaapi -frames:v 1000 out.mp4


test.cl:

__kernel void rotate_image(__write_only image2d_t dst,
                           __read_only  image2d_t src,
                           unsigned int index)
{
  const sampler_t sampler = (CLK_NORMALIZED_COORDS_FALSE |
                             CLK_FILTER_LINEAR);

  float angle = (float)index / 100;

  float2 dst_dim = convert_float2(get_image_dim(dst));
  float2 src_dim = convert_float2(get_image_dim(src));

  float2 dst_cen = dst_dim / 2;
  float2 src_cen = src_dim / 2;

  int2   dst_loc = (int2)(get_global_id(0), get_global_id(1));

  float2 dst_pos = convert_float2(dst_loc) - dst_cen;
  float2 src_pos = {
    cos(angle) * dst_pos.x - sin(angle) * dst_pos.y,
    sin(angle) * dst_pos.x + cos(angle) * dst_pos.y
  };
  src_pos = src_pos * src_dim / dst_dim;

  float2 src_loc = src_pos + src_cen;

  if (src_loc.x < 0         || src_loc.y < 0 ||
      src_loc.x > src_dim.x || src_loc.y > src_dim.y)
    write_imagef(dst, dst_loc, 0.5);
  else
    write_imagef(dst, dst_loc, read_imagef(src, sampler, src_loc));
}


Image *VASurface::createSharedVaSurface(Context *context, VASharingFunctions *sharingFunctions,
                                        cl_mem_flags flags, VASurfaceID *surface,
                                        cl_uint plane, cl_int *errcodeRet)


./ffmpeg -i ../../../Videos/a.ts -filter_complex "minterpolate=mi_mode=blend:scd=fdiff:scd_threshold=1" -f null /dev/null

./ffmpeg -i ../../../Videos/a.ts -filter_complex "minterpolate=mi_mode=mci:mc_mode=aobmc:vsbmc=1" -f null /dev/null

git diff d7bc52bf456deba0f32d9fe5c288ec441f1ebef5^..d7bc52bf456deba0f32d9fe5c288ec441f1ebef5 // fast copy (SSE4)

https://blogs.gnome.org/rbultje/2017/07/14/writing-x86-simd-using-x86inc-asm/


./ffmpeg -hwaccel vaapi -hwaccel_output_format vaapi -i ../../../Videos/Allegro_HEVC_Main_HT50_INTRA_07_192x200@60Hz_3.1.bin -f null /dev/null -loglevel 99 // auto insert scale

hls_slice_header

(gdb) bt
#0  configure_output_video_filter (fg=0x555557a9bd80, ofilter=0x555557a52a00, out=0x555557d13300) at fftools/ffmpeg_filter.c:448
#1  0x0000555555653b5f in configure_output_filter (fg=0x555557a9bd80, ofilter=0x555557a52a00, out=0x555557d13300) at fftools/ffmpeg_filter.c:677
#2  0x000055555565576b in configure_filtergraph (fg=0x555557a9bd80) at fftools/ffmpeg_filter.c:1098
#3  0x0000555555666881 in ifilter_send_frame (ifilter=0x555557ce4640, frame=0x555557d39680) at fftools/ffmpeg.c:2187
#4  0x0000555555666ba7 in send_frame_to_filters (ist=0x555557a50a40, decoded_frame=0x555557d39680) at fftools/ffmpeg.c:2268
#5  0x0000555555667a14 in decode_video (ist=0x555557a50a40, pkt=0x7fffffffd030, got_output=0x7fffffffd018, duration_pts=0x7fffffffd028, eof=0, decode_failed=0x7fffffffd020)
    at fftools/ffmpeg.c:2469
#6  0x0000555555668437 in process_input_packet (ist=0x555557a50a40, pkt=0x7fffffffd270, no_eof=0) at fftools/ffmpeg.c:2623
#7  0x000055555566fe28 in process_input (file_index=0) at fftools/ffmpeg.c:4505
#8  0x00005555556703e7 in transcode_step () at fftools/ffmpeg.c:4625
#9  0x0000555555670564 in transcode () at fftools/ffmpeg.c:4679
#10 0x0000555555670f34 in main (argc=13, argv=0x7fffffffdbd8) at fftools/ffmpeg.c:4886

gdb) bt
#0  configure_output_video_filter (fg=0x555557a9bd80, ofilter=0x555557a52a00, out=0x555557ac6800) at fftools/ffmpeg_filter.c:448
#1  0x0000555555653b5f in configure_output_filter (fg=0x555557a9bd80, ofilter=0x555557a52a00, out=0x555557ac6800) at fftools/ffmpeg_filter.c:677
#2  0x000055555565576b in configure_filtergraph (fg=0x555557a9bd80) at fftools/ffmpeg_filter.c:1098
#3  0x0000555555666881 in ifilter_send_frame (ifilter=0x555557ce4640, frame=0x555557d39680) at fftools/ffmpeg.c:2187
#4  0x0000555555666ba7 in send_frame_to_filters (ist=0x555557a50a40, decoded_frame=0x555557d39680) at fftools/ffmpeg.c:2268
#5  0x0000555555667a14 in decode_video (ist=0x555557a50a40, pkt=0x7fffffffd030, got_output=0x7fffffffd018, duration_pts=0x7fffffffd028, eof=0, decode_failed=0x7fffffffd020)
    at fftools/ffmpeg.c:2469
#6  0x0000555555668437 in process_input_packet (ist=0x555557a50a40, pkt=0x7fffffffd270, no_eof=0) at fftools/ffmpeg.c:2623
#7  0x000055555566fe28 in process_input (file_index=0) at fftools/ffmpeg.c:4505
#8  0x00005555556703e7 in transcode_step () at fftools/ffmpeg.c:4625
#9  0x0000555555670564 in transcode () at fftools/ffmpeg.c:4679
#10 0x0000555555670f34 in main (argc=13, argv=0x7fffffffdbd8) at fftools/ffmpeg.c:4886

ifilter_send_frame // need_reinit // why
(ifilter->hw_frames_ctx && ifilter->hw_frames_ctx->data != frame->hw_frames_ctx->data)

Number 1: 
(gdb) bt
#0  av_hwframe_ctx_alloc (device_ref_in=0x555557ab3200) at libavutil/hwcontext.c:244
#1  0x0000555555c19412 in avcodec_get_hw_frames_parameters (avctx=0x555557ab47c0, device_ref=0x555557ab3200, hw_pix_fmt=AV_PIX_FMT_VAAPI_VLD, out_frames_ref=0x555557ab4bb0)
    at libavcodec/decode.c:1223
#2  0x0000555555c192e5 in ff_decode_get_hw_frames_ctx (avctx=0x555557ab47c0, dev_type=AV_HWDEVICE_TYPE_VAAPI) at libavcodec/decode.c:1176
#3  0x00005555567773ea in ff_vaapi_decode_init (avctx=0x555557ab47c0) at libavcodec/vaapi_decode.c:659
#4  0x0000555555c195c3 in hwaccel_init (avctx=0x555557ab47c0, hw_config=0x5555571d85b0 <__compound_literal.0>) at libavcodec/decode.c:1273
#5  0x0000555555c19ac0 in ff_get_format (avctx=0x555557ab47c0, fmt=0x7fffebfb0c2c) at libavcodec/decode.c:1412
#6  0x0000555555f4df9a in ff_thread_get_format (avctx=0x555557ab47c0, fmt=0x7fffebfb0c2c) at libavcodec/pthread_frame.c:945
#7  0x0000555555d0fb1e in get_format (s=0x555557a4d880, sps=0x555557acb940) at libavcodec/hevcdec.c:421
#8  0x0000555555d10258 in hls_slice_header (s=0x555557a4d880) at libavcodec/hevcdec.c:529
#9  0x0000555555d1aedf in decode_nal_unit (s=0x555557a4d880, nal=0x7fffe4011218) at libavcodec/hevcdec.c:2915
#10 0x0000555555d1b5b6 in decode_nal_units (s=0x555557a4d880, buf=0x555557a84b10 "", length=22175) at libavcodec/hevcdec.c:3056
#11 0x0000555555d1bbcd in hevc_decode_frame (avctx=0x555557ab47c0, data=0x555557ab4c80, got_output=0x555557ab9ba0, avpkt=0x555557ab9b40) at libavcodec/hevcdec.c:3192
#12 0x0000555555f4ba23 in frame_worker_thread (arg=0x555557ab9a40) at libavcodec/pthread_frame.c:201
#13 0x00007ffff38616db in start_thread (arg=0x7fffebfb1700) at pthread_create.c:463
#14 0x00007ffff358a88f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95

(gdb) bt
#0  av_hwframe_ctx_init (ref=0x7fffe401ac80) at libavutil/hwcontext.c:331
#1  0x0000555555c19335 in ff_decode_get_hw_frames_ctx (avctx=0x555557ab47c0, dev_type=AV_HWDEVICE_TYPE_VAAPI) at libavcodec/decode.c:1192
#2  0x00005555567773ea in ff_vaapi_decode_init (avctx=0x555557ab47c0) at libavcodec/vaapi_decode.c:659
#3  0x0000555555c195c3 in hwaccel_init (avctx=0x555557ab47c0, hw_config=0x5555571d85b0 <__compound_literal.0>) at libavcodec/decode.c:1273
#4  0x0000555555c19ac0 in ff_get_format (avctx=0x555557ab47c0, fmt=0x7fffebfb0c2c) at libavcodec/decode.c:1412
#5  0x0000555555f4df9a in ff_thread_get_format (avctx=0x555557ab47c0, fmt=0x7fffebfb0c2c) at libavcodec/pthread_frame.c:945
#6  0x0000555555d0fb1e in get_format (s=0x555557a4d880, sps=0x555557acb940) at libavcodec/hevcdec.c:421
#7  0x0000555555d10258 in hls_slice_header (s=0x555557a4d880) at libavcodec/hevcdec.c:529
#8  0x0000555555d1aedf in decode_nal_unit (s=0x555557a4d880, nal=0x7fffe4011218) at libavcodec/hevcdec.c:2915
#9  0x0000555555d1b5b6 in decode_nal_units (s=0x555557a4d880, buf=0x555557a84b10 "", length=22175) at libavcodec/hevcdec.c:3056
#10 0x0000555555d1bbcd in hevc_decode_frame (avctx=0x555557ab47c0, data=0x555557ab4c80, got_output=0x555557ab9ba0, avpkt=0x555557ab9b40) at libavcodec/hevcdec.c:3192
#11 0x0000555555f4ba23 in frame_worker_thread (arg=0x555557ab9a40) at libavcodec/pthread_frame.c:201
#12 0x00007ffff38616db in start_thread (arg=0x7fffebfb1700) at pthread_create.c:463
#13 0x00007ffff358a88f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95

hls_slice_header

Number 2:
(gdb) bt
#0  av_hwframe_ctx_alloc (device_ref_in=0x555557ab3200) at libavutil/hwcontext.c:244
#1  0x0000555555c19412 in avcodec_get_hw_frames_parameters (avctx=0x555557adf600, device_ref=0x555557ab3200, hw_pix_fmt=AV_PIX_FMT_VAAPI_VLD, out_frames_ref=0x555557adf9f0)
    at libavcodec/decode.c:1223
#2  0x0000555555c192e5 in ff_decode_get_hw_frames_ctx (avctx=0x555557adf600, dev_type=AV_HWDEVICE_TYPE_VAAPI) at libavcodec/decode.c:1176
#3  0x00005555567773ea in ff_vaapi_decode_init (avctx=0x555557adf600) at libavcodec/vaapi_decode.c:659
#4  0x0000555555c195c3 in hwaccel_init (avctx=0x555557adf600, hw_config=0x5555571d85b0 <__compound_literal.0>) at libavcodec/decode.c:1273
#5  0x0000555555c19ac0 in ff_get_format (avctx=0x555557adf600, fmt=0x7fffeafaec2c) at libavcodec/decode.c:1412
#6  0x0000555555f4df9a in ff_thread_get_format (avctx=0x555557adf600, fmt=0x7fffeafaec2c) at libavcodec/pthread_frame.c:945
#7  0x0000555555d0fb1e in get_format (s=0x555557d08500, sps=0x7fffe0030e00) at libavcodec/hevcdec.c:421
#8  0x0000555555d10258 in hls_slice_header (s=0x555557d08500) at libavcodec/hevcdec.c:529
#9  0x0000555555d1aedf in decode_nal_unit (s=0x555557d08500, nal=0x7fffe001b758) at libavcodec/hevcdec.c:2915
#10 0x0000555555d1b5b6 in decode_nal_units (s=0x555557d08500, buf=0x555557a7e740 "", length=21657) at libavcodec/hevcdec.c:3056
#11 0x0000555555d1bbcd in hevc_decode_frame (avctx=0x555557adf600, data=0x555557ac92c0, got_output=0x555557ab9f00, avpkt=0x555557ab9ea0) at libavcodec/hevcdec.c:3192
#12 0x0000555555f4ba23 in frame_worker_thread (arg=0x555557ab9da0) at libavcodec/pthread_frame.c:201
#13 0x00007ffff38616db in start_thread (arg=0x7fffeafaf700) at pthread_create.c:463
#14 0x00007ffff358a88f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95

(gdb) bt
#0  av_hwframe_ctx_init (ref=0x7fffe000fc80) at libavutil/hwcontext.c:331
#1  0x0000555555c19335 in ff_decode_get_hw_frames_ctx (avctx=0x555557adf600, dev_type=AV_HWDEVICE_TYPE_VAAPI) at libavcodec/decode.c:1192
#2  0x00005555567773ea in ff_vaapi_decode_init (avctx=0x555557adf600) at libavcodec/vaapi_decode.c:659
#3  0x0000555555c195c3 in hwaccel_init (avctx=0x555557adf600, hw_config=0x5555571d85b0 <__compound_literal.0>) at libavcodec/decode.c:1273
#4  0x0000555555c19ac0 in ff_get_format (avctx=0x555557adf600, fmt=0x7fffeafaec2c) at libavcodec/decode.c:1412
#5  0x0000555555f4df9a in ff_thread_get_format (avctx=0x555557adf600, fmt=0x7fffeafaec2c) at libavcodec/pthread_frame.c:945
#6  0x0000555555d0fb1e in get_format (s=0x555557d08500, sps=0x7fffe0030e00) at libavcodec/hevcdec.c:421
#7  0x0000555555d10258 in hls_slice_header (s=0x555557d08500) at libavcodec/hevcdec.c:529
#8  0x0000555555d1aedf in decode_nal_unit (s=0x555557d08500, nal=0x7fffe001b758) at libavcodec/hevcdec.c:2915
#9  0x0000555555d1b5b6 in decode_nal_units (s=0x555557d08500, buf=0x555557a7e740 "", length=21657) at libavcodec/hevcdec.c:3056
#10 0x0000555555d1bbcd in hevc_decode_frame (avctx=0x555557adf600, data=0x555557ac92c0, got_output=0x555557ab9f00, avpkt=0x555557ab9ea0) at libavcodec/hevcdec.c:3192
#11 0x0000555555f4ba23 in frame_worker_thread (arg=0x555557ab9da0) at libavcodec/pthread_frame.c:201
#12 0x00007ffff38616db in start_thread (arg=0x7fffeafaf700) at pthread_create.c:463
#13 0x00007ffff358a88f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95

./ffmpeg_g -threads 1 -thread_type slice+frame -hwaccel vaapi  -hwaccel_device /dev/dri/renderD128 -hwaccel_output_format vaapi -i  ../../../Videos/Allegro_HEVC_Main_HT50_INTRA_07_192x200@60Hz_3.1.bin -f null /dev/null -loglevel 99 -report


cbs_h2645_assemble_fragment() // start code


codename=$(lsb_release -c | awk  '{print $2}')
sudo tee /etc/apt/sources.list.d/ddebs.list << EOF
deb http://ddebs.ubuntu.com/ ${codename}      main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-security main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-updates  main restricted universe multiverse
deb http://ddebs.ubuntu.com/ ${codename}-proposed main restricted universe multiverse
EOF

sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys ECDCAD72428D7C01
sudo apt-get update
sudo apt-get install linux-image-$(uname -r)-dbgsym


#0  write_packet (of=0x555557a38240, pkt=0x7fffffffcf60, ost=0x555557a91600, unqueue=0) at fftools/ffmpeg.c:717
#1  0x0000555555660da0 in output_packet (of=0x555557a38240, pkt=0x7fffffffcf60, ost=0x555557a91600, eof=0) at fftools/ffmpeg.c:886
#2  0x0000555555666552 in do_streamcopy (ist=0x555557a38300, ost=0x555557a91600, pkt=0x7fffffffd2c0) at fftools/ffmpeg.c:2080
#3  0x00005555556690c5 in process_input_packet (ist=0x555557a38300, pkt=0x7fffffffd2c0, no_eof=0) at fftools/ffmpeg.c:2746
#4  0x00005555556701df in process_input (file_index=0) at fftools/ffmpeg.c:4505
#5  0x000055555567079e in transcode_step () at fftools/ffmpeg.c:4625
#6  0x000055555567091b in transcode () at fftools/ffmpeg.c:4679
#7  0x00005555556712eb in main (argc=13, argv=0x7fffffffdc28) at fftools/ffmpeg.c:4886

https://www.freedesktop.org/wiki/Software/PulseAudio/HowToUseGitSendEmail/  // git send patch

./ffmpeg -i ../../../Videos/skyfall2-trailer.mp4 -c copy -listen 1  -movflags frag_keyframe+empty_moov -f mp4 http://192.168.100.209:8999

./ffmpeg -re -i ~/Downloads/ToS-4k-1920.mov -vcodec libx264 -g 50 -refs 1 -s 640x360 -b:v 1000k -acodec aac -b:a 64k -flush_packets 0 -f mpegts "srt://127.0.0.1:5555?mode=listener"
ffplay srt://127.0.0.1:5555


./ffmpeg_g -v 55 -y -threads 1 -hwaccel vaapi -hwaccel_device /dev/dri/renderD128 -hwaccel_output_format vaapi -i ~/video/test/bbb_1080_264.mp4 -an -c:v h264_vaapi -slices 2 -frames:v 1 test.264
./ffmpeg -i test.264 out.mjpeg

1. static void dump_sidedata(void *ctx, AVStream *st, const char *indent)
2. const char *av_frame_side_data_name(enum AVFrameSideDataType type)


1. ./ffmpeg -hwaccel vaapi -vaapi_device /dev/dri/renderD128 -hwaccel_output_format vaapi -i ../../../Videos/skyfall2-trailer.mp4 -f null /dev/null
   ./ffmpeg -hwaccel vaapi -vaapi_device /dev/dri/renderD128 -i ../../../Videos/skyfall2-trailer.mp4 -f null /dev/null


(gdb) bt
DdiMedia_MediaFormatToOsFormat   // (gdb) p buf->format $48 = Media_Format_CPU
#0  DdiMedia_MapBufferInternal (ctx=0x555557a9a2a0, buf_id=0, pbuf=0x7fffffffca48, flag=3)
    at /home/barry/Sources/umd_dev/media-driver/media_driver/linux/common/ddi/media_libva.cpp:2818
#1  0x00007fffeb1337aa in DdiMedia_MapBuffer (ctx=0x555557a9a2a0, buf_id=0, pbuf=0x7fffffffca48)
    at /home/barry/Sources/umd_dev/media-driver/media_driver/linux/common/ddi/media_libva.cpp:2846
#2  0x00007fffeb1390ac in DdiMedia_GetImage (ctx=0x555557a9a2a0, surface=24, x=0, y=0, width=1920, height=1088, image=0)
    at /home/barry/Sources/umd_dev/media-driver/media_driver/linux/common/ddi/media_libva.cpp:4408
#3  0x0000555556a864ca in vaapi_map_frame (hwfc=0x7fffe0052100, dst=0x555557f01e00, src=0x555557bf4d00, flags=1) at libavutil/hwcontext_vaapi.c:784
#4  0x0000555556a8678e in vaapi_transfer_data_from (hwfc=0x7fffe0052100, dst=0x555557a9b900, src=0x555557bf4d00) at libavutil/hwcontext_vaapi.c:852
#5  0x0000555556a7feb5 in av_hwframe_transfer_data (dst=0x555557a9b900, src=0x555557bf4d00, flags=0) at libavutil/hwcontext.c:450
#6  0x0000555556a7fdcb in transfer_data_alloc (dst=0x555557a9b680, src=0x555557bf4d00, flags=0) at libavutil/hwcontext.c:425
#7  0x0000555556a7fe6a in av_hwframe_transfer_data (dst=0x555557a9b680, src=0x555557bf4d00, flags=0) at libavutil/hwcontext.c:445
#8  0x000055555565b82c in hwaccel_retrieve_data (avctx=0x555557a98380, input=0x555557bf4d00) at fftools/ffmpeg_hw.c:448
#9  0x000055555566c18f in decode_video (ist=0x555557a98dc0, pkt=0x7fffffffcec0, got_output=0x7fffffffcea8, duration_pts=0x7fffffffceb8, eof=0, decode_failed=0x7fffffffceb0)
    at fftools/ffmpeg.c:2430
#10 0x000055555566cf9d in process_input_packet (ist=0x555557a98dc0, pkt=0x7fffffffd100, no_eof=0) at fftools/ffmpeg.c:2625
#11 0x000055555567498e in process_input (file_index=0) at fftools/ffmpeg.c:4507
#12 0x0000555555674f4d in transcode_step () at fftools/ffmpeg.c:4627
#13 0x00005555556750ca in transcode () at fftools/ffmpeg.c:4681
#14 0x0000555555675a9a in main (argc=15, argv=0x7fffffffda68) at fftools/ffmpeg.c:4888

DdiMedia_CreateImage //   buf->format            = Media_Format_CPU;//DdiCodec_OsFormatToMediaFormat(vaimg->format.fourcc); //Media_Format_Buffer;
a9a07fc9 lead to the issue


在前10秒应显示底帧:

blend=all_expr='A*(if(gte(T,10),1,T/10))+B*(1-(if(gte(T,10),1,T/10)))'

显示1x1棋盘效应效果（有的显示A，有的显示B）:

blend=all_expr='if(eq(mod(X,2),mod(Y,2)),A,B)'

从左到右揭开的效果:

blend=all_expr='if(gte(N*SW+X,W),A,B)'

从上到下揭开效果:

blend=all_expr='if(gte(Y-N*SH,0),A,B)'

从右下向左上揭开效果：

blend=all_expr='if(gte(TSH40+Y,H)gte((T40*SW+X)*W/H,W),A,B)'

显示当前和前一帧之间的差异:

tblend=all_mode=difference128

使用举例：

ffmpeg -i out31.avi -i out32.avi -filter_complex "blend=all_expr='if(gte(T*SH*200+Y,H)*gte((T*200*SW+X)

BlendPlaneRow

uint8_t src0[]  = {0x01, 0x23, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE};
uint8_t src1[]  = {0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x23};
uint8_t alpha[] = {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55};

(gdb) p /x $xmm6
$17 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x80, 0x80, 0x80, 0x80, 0x0 <repeats 12 times>}, v8_int16 = {0x8080, 0x8080, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x0}, v4_int32 = {0x80808080, 0x0, 0x0, 0x0}, v2_int64 = {0x80808080, 0x0}, uint128 = 0x80808080}
(gdb) p /x $xmm5
$18 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x8000000000000000, 0x8000000000000000}, v16_int8 = {0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 
    0xff, 0x0, 0xff}, v8_int16 = {0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00}, v4_int32 = {0xff00ff00, 0xff00ff00, 0xff00ff00, 0xff00ff00}, v2_int64 = {
    0xff00ff00ff00ff00, 0xff00ff00ff00ff00}, uint128 = 0xff00ff00ff00ff00ff00ff00ff00ff00}
(gdb) p /x $xmm6
$19 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x80, 0x80, 0x80, 0x80, 0x0 <repeats 12 times>}, v8_int16 = {0x8080, 0x8080, 0x0, 0x0, 0x0, 0x0, 0x0, 
    0x0}, v4_int32 = {0x80808080, 0x0, 0x0, 0x0}, v2_int64 = {0x80808080, 0x0}, uint128 = 0x80808080}
(gdb) p /x $xmm7
$20 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x0 <repeats 16 times>}, v8_int16 = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x0, 0x0, 0x0, 
    0x0}, v2_int64 = {0x0, 0x0}, uint128 = 0x0}



//
(gdb) p /x $xmm5
$21 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x8000000000000000, 0x8000000000000000}, v16_int8 = {0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 
    0xff, 0x0, 0xff}, v8_int16 = {0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00}, v4_int32 = {0xff00ff00, 0xff00ff00, 0xff00ff00, 0xff00ff00}, v2_int64 = {
    0xff00ff00ff00ff00, 0xff00ff00ff00ff00}, uint128 = 0xff00ff00ff00ff00ff00ff00ff00ff00}
(gdb) p /x $xmm6
$22 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x80 <repeats 16 times>}, v8_int16 = {0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080}, 
  v4_int32 = {0x80808080, 0x80808080, 0x80808080, 0x80808080}, v2_int64 = {0x8080808080808080, 0x8080808080808080}, uint128 = 0x80808080808080808080808080808080}
(gdb) p /x $xmm7
$23 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80}, 
  v8_int16 = {0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f}, v4_int32 = {0x807f807f, 0x807f807f, 0x807f807f, 0x807f807f}, v2_int64 = {0x807f807f807f807f, 
    0x807f807f807f807f}, uint128 = 0x807f807f807f807f807f807f807f807f}


void ff_global_blend_row_ssse3(const uint8_t *src0,
                                      const uint8_t *src1,
                                      const uint8_t *alpha,
                                      uint8_t *dst,
                                      int width)
{
  __asm__ volatile(
      "pcmpeqb    %%xmm5,%%xmm5                  \n" xmm5 = {0xff, 0xff, oxff, oxff, 0xff, 0xff, oxff, oxff, 0xff, 0xff, oxff, oxff, 0xff, 0xff, oxff, oxff}
      "psllw      $0x8,%%xmm5                    \n" xmm5 = {0x00, 0xff, ox00, oxff, 0x00, 0xff, ox00, oxff, 0x00, 0xff, ox00, oxff, 0x00, 0xff, ox00, oxff} // xmm5 = xmm5 << 8
      "mov        $0x80808080,%%eax              \n" eax  = 0x80808080
      "movd       %%eax,%%xmm6                   \n" xmm6 = v16_int8 = {0x80, 0x80, 0x80, 0x80, 0x0 <repeats 12 times>},
      "pshufd     $0x0,%%xmm6,%%xmm6             \n" xmm6 = v16_int8 = {0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}
      "mov        $0x807f807f,%%eax              \n" eax  = 0x807f807f
      "movd       %%eax,%%xmm7                   \n" xmm7 = v16_int8 = {0x7f, 0x80, 0x7f, 0x80, 0x0 <repeats 12 times>}
      "pshufd     $0x0,%%xmm7,%%xmm7             \n" xmm7 = v16_int8 = {0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80}
      "sub        %2,%0                          \n" $0 = $0 - $2
      "sub        %2,%1                          \n" $1 = $1 - $2
      "sub        %2,%3                          \n" $3 = $3 - $2
(gdb) p /x $xmm5
$21 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x8000000000000000, 0x8000000000000000}, v16_int8 = {0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 
    0xff, 0x0, 0xff}, v8_int16 = {0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00, 0xff00}, v4_int32 = {0xff00ff00, 0xff00ff00, 0xff00ff00, 0xff00ff00}, v2_int64 = {
    0xff00ff00ff00ff00, 0xff00ff00ff00ff00}, uint128 = 0xff00ff00ff00ff00ff00ff00ff00ff00}
(gdb) p /x $xmm6
$22 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x80 <repeats 16 times>}, v8_int16 = {0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080}, 
  v4_int32 = {0x80808080, 0x80808080, 0x80808080, 0x80808080}, v2_int64 = {0x8080808080808080, 0x8080808080808080}, uint128 = 0x80808080808080808080808080808080}
(gdb) p /x $xmm7
$23 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80}, 
  v8_int16 = {0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f}, v4_int32 = {0x807f807f, 0x807f807f, 0x807f807f, 0x807f807f}, v2_int64 = {0x807f807f807f807f, 
    0x807f807f807f807f}, uint128 = 0x807f807f807f807f807f807f807f807f}

      // 8 pixel loop.
      "1:                                        \n"
      "movq       (%2),%%xmm0                    \n" // Fixme load $2 => xmm0
                                                     // xmm0 = v16_int8 = {0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0} // 8 Bytes
      "punpcklbw  %%xmm0,%%xmm0                  \n" // xmm0 = v16_int8 = {0x55 <repeats 16 times>} // 16 Bytes
      "pxor       %%xmm5,%%xmm0                  \n" // xmm0 = v16_int8 = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
                                                     //  0x55 + 0xaa = 0xff
(gdb) p /x $xmm0 
$29 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa}, 
  v8_int16 = {0xaa55, 0xaa55, 0xaa55, 0xaa55, 0xaa55, 0xaa55, 0xaa55, 0xaa55}, v4_int32 = {0xaa55aa55, 0xaa55aa55, 0xaa55aa55, 0xaa55aa55}, v2_int64 = {0xaa55aa55aa55aa55, 
    0xaa55aa55aa55aa55}, uint128 = 0xaa55aa55aa55aa55aa55aa55aa55aa55}

      "movq       (%0,%2,1),%%xmm1               \n" // xmm1 = v16_int8 = {0x1, 0x23, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
      "movq       (%1,%2,1),%%xmm2               \n" // xmm2 = v16_int8 = {0xf0, 0xde, 0xbc, 0x9a, 0x78, 0x56, 0x34, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},
      "punpcklbw  %%xmm2,%%xmm1                  \n" // xmm1 = v16_int8 = {0x1, 0xf0, 0x23, 0xde, 0x34, 0xbc, 0x56, 0x9a, 0x78, 0x78, 0x9a, 0x56, 0xbc, 0x34, 0xde, 0x23},
                                                     // xmm1 = xmm1 + xmm2 unpackb

uint8_t src1[]  = {0xF0, 0xDE, 0xBC, 0x9A, 0x78, 0x56, 0x34, 0x23};      
(gdb) p /x $xmm2
$30 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0xf0, 0xde, 0xbc, 0x9a, 0x78, 0x56, 0x34, 0x23, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v8_int16 = {
    0xdef0, 0x9abc, 0x5678, 0x2334, 0x0, 0x0, 0x0, 0x0}, v4_int32 = {0x9abcdef0, 0x23345678, 0x0, 0x0}, v2_int64 = {0x233456789abcdef0, 0x0}, uint128 = 0x233456789abcdef0}

uint8_t src0[]  = {0x01, 0x23, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE};
(gdb) p /x $xmm1 src0/src1 interlace [XXXX]
$31 = {v4_float = {0x0, 0x0, 0x3c000000, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x1, 0xf0, 0x23, 0xde, 0x34, 0xbc, 0x56, 0x9a, 0x78, 0x78, 0x9a, 0x56, 0xbc, 0x34, 0xde, 0x23}, 
  v8_int16 = {0xf001, 0xde23, 0xbc34, 0x9a56, 0x7878, 0x569a, 0x34bc, 0x23de}, v4_int32 = {0xde23f001, 0x9a56bc34, 0x569a7878, 0x23de34bc}, v2_int64 = {0x9a56bc34de23f001, 
    0x23de34bc569a7878}, uint128 = 0x23de34bc569a78789a56bc34de23f001}

      "psubb      %%xmm6,%%xmm1                  \n" // xmm1 - xmm6 => xmm1  0x01 - 0x80 = 0x01 + 0x80 if (a<b) a+b else a-b
                                                     // xmm1 = v16_int8 = {0x81, 0x70, 0xa3, 0x5e, 0xb4, 0x3c, 0xd6, 0x1a, 0xf8, 0xf8, 0x1a, 0xd6, 0x3c, 0xb4, 0x5e, 0xa3},
						     // xmm0 = v16_int8 = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
(gdb) p /x $xmm1
$32 = {v4_float = {0x0, 0x0, 0xc2000000, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x81, 0x70, 0xa3, 0x5e, 0xb4, 0x3c, 0xd6, 0x1a, 0xf8, 0xf8, 0x1a, 0xd6, 0x3c, 0xb4, 0x5e, 0xa3}, 
  v8_int16 = {0x7081, 0x5ea3, 0x3cb4, 0x1ad6, 0xf8f8, 0xd61a, 0xb43c, 0xa35e}, v4_int32 = {0x5ea37081, 0x1ad63cb4, 0xd61af8f8, 0xa35eb43c}, v2_int64 = {0x1ad63cb45ea37081, 
    0xa35eb43cd61af8f8}, uint128 = 0xa35eb43cd61af8f81ad63cb45ea37081}
(gdb) p /x $xmm6
$33 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x80 <repeats 16 times>}, v8_int16 = {0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080, 0x8080}, 
  v4_int32 = {0x80808080, 0x80808080, 0x80808080, 0x80808080}, v2_int64 = {0x8080808080808080, 0x8080808080808080}, uint128 = 0x80808080808080808080808080808080}
  
      "pmaddubsw  %%xmm1,%%xmm0                  \n" // 按照字节对应位置做乘法，在把相邻两数相加，饱和在16位有符号数。 DST = xmm0 SRC = xmm1
                                                     // xmm1 = v16_int8 = {0x81, 0x70, 0xa3, 0x5e, 0xb4, 0x3c, 0xd6, 0x1a, 0xf8, 0xf8, 0x1a, 0xd6, 0x3c, 0xb4, 0x5e, 0xa3},
						     // xmm0 = v16_int8 = {0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa},
						     // after
						     // xmm0 = v16_int8 = {0x35, 0x20, 0x8b, 0x1f, 0x9c, 0xe, 0x52, 0x3, 0x8, 0xf8, 0xbe, 0xec, 0x74, 0xe1, 0x74, 0xe1}
						             = v8_int16 = {0x2035, 0x1f8b, 0xe9c, 0x352, 0xf808, 0xecbe, 0xe174, 0xe174}
                                                     // DEST[15:0] ←SaturateToSignedWord(SRC[15:8]*DST[15:8]   + SRC[7:0]*DST[7:0]);
　　                                                  // DEST[31:16]←SaturateToSignedWord(SRC[31:24]*DST[31:24] + SRC[23:16]*DST[23:16]);
　　                                                  // DEST[47:32]←SaturateToSignedWord(SRC[47:40]*DST[47:40] + SRC[39:32]*DST[39:32]);
　　                                                  // DEST[63:48]←SaturateToSignedWord(SRC[63:56]*DST[63:56] + SRC[55:48]*DST[55:48]);
						     // xmm0 = (xmm0 * xmm1 + xmm1)
						     // Byte0 =  0x70 * 0xaa + 0x81 * 0x55 = 0x7535  //0x75 - 0x20 = 0x55
						     //          0x5e * 0xaa + 0xa3 * 0x55 = 0x748b  //0x74 - 0x1f = 0x55
						     //          0x3c * 0xaa + 0xb4 * 0x55 = 0x639c  //0x63 - 0xe  = 0x55
						     //          0x1a * 0xaa + 0xd6 * 0x55 = 0x5852  //0x58 - 0x3  = 0x55
						     //          0xf8 * 0xaa + 0xf8 * 0x55 = 0xf708  // 0xf7 + 1        = 0xf8
						     //          0xd6 * 0xaa + 0x1a * 0x55 = 0x98be  // 0x98 + 0x55 - 1 = 0xec
						     //          0xb4 * 0xaa + 0x3c * 0x55 = 0x8b74  // 0x8b + 0x55 + 1 = 0xe1
						     //          0xa3 * 0xaa + 0x5e * 0x55 = 0x8b74  // 0x8b + 0x55 + 1 = 0xe1
(gdb) p /x $xmm1
$34 = {v4_float = {0x0, 0x0, 0xc2000000, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x81, 0x70, 0xa3, 0x5e, 0xb4, 0x3c, 0xd6, 0x1a, 0xf8, 0xf8, 0x1a, 0xd6, 0x3c, 0xb4, 0x5e, 0xa3}, 
  v8_int16 = {0x7081, 0x5ea3, 0x3cb4, 0x1ad6, 0xf8f8, 0xd61a, 0xb43c, 0xa35e}, v4_int32 = {0x5ea37081, 0x1ad63cb4, 0xd61af8f8, 0xa35eb43c}, v2_int64 = {0x1ad63cb45ea37081, 
    0xa35eb43cd61af8f8}, uint128 = 0xa35eb43cd61af8f81ad63cb45ea37081}
(gdb) p /x $xmm0
$35 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x8000000000000000}, v16_int8 = {0x35, 0x20, 0x8b, 0x1f, 0x9c, 0xe, 0x52, 0x3, 0x8, 0xf8, 0xbe, 0xec, 0x74, 0xe1, 0x74, 
    0xe1}, v8_int16 = {0x2035, 0x1f8b, 0xe9c, 0x352, 0xf808, 0xecbe, 0xe174, 0xe174}, v4_int32 = {0x1f8b2035, 0x3520e9c, 0xecbef808, 0xe174e174}, v2_int64 = {0x3520e9c1f8b2035, 
    0xe174e174ecbef808}, uint128 = 0xe174e174ecbef80803520e9c1f8b2035}
    
      "paddw      %%xmm7,%%xmm0                  \n"  // PADDW instruction with 128-bit operands:
                                                      // DEST[15-0] DEST[15-0] + SRC[15-0];
                                                      // * repeat add operation for 2nd through 7th word *;
                                                      // DEST[127-112] DEST[127-112] + SRC[127-112];
						      // xmm0 = v16_int8 = {0x35, 0x20, 0x8b, 0x1f, 0x9c, 0xe, 0x52, 0x3, 0x8, 0xf8, 0xbe, 0xec, 0x74, 0xe1, 0x74, 0xe1}
						             = v8_int16 = {0x2035, 0x1f8b, 0xe9c,  0x352,  0xf808, 0xecbe, 0xe174, 0xe174}
						      // xmm7= v8_int16 = {0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f},
						      // xmm0= v8_int16 = {0xa0b4, 0xa00a, 0x8f1b, 0x83d1, 0x7887, 0x6d3d, 0x61f3, 0x61f3}
						      //  xmm0 word0 = 0x2035 + 0x807f = 0xa0b4
						      //       word1 = 0x1f8b + 0x807f = 0xa00a
						      //       word2 = 0xe9c  + 0x807f = 0x8f1b
						      //       ...
						      //       word7 = 0xe174 + 0x807f = 0x161fc = 0x61fc
(gdb) p /x $xmm7                      
$36 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80, 0x7f, 0x80}, 
  v8_int16 = {0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f, 0x807f}, v4_int32 = {0x807f807f, 0x807f807f, 0x807f807f, 0x807f807f}, v2_int64 = {0x807f807f807f807f, 
    0x807f807f807f807f}, uint128 = 0x807f807f807f807f807f807f807f807f}
(gdb) p /x $xmm0
$37 = {v4_float = {0x0, 0x0, 0xffffffff, 0xffffffff}, v2_double = {0x0, 0x7fffffffffffffff}, v16_int8 = {0xb4, 0xa0, 0xa, 0xa0, 0x1b, 0x8f, 0xd1, 0x83, 0x87, 0x78, 0x3d, 0x6d, 0xf3, 
    0x61, 0xf3, 0x61}, v8_int16 = {0xa0b4, 0xa00a, 0x8f1b, 0x83d1, 0x7887, 0x6d3d, 0x61f3, 0x61f3}, v4_int32 = {0xa00aa0b4, 0x83d18f1b, 0x6d3d7887, 0x61f361f3}, v2_int64 = {
    0x83d18f1ba00aa0b4, 0x61f361f36d3d7887}, uint128 = 0x61f361f36d3d788783d18f1ba00aa0b4}

      "psrlw      $0x8,%%xmm0                    \n" xmm0 = xmm0 << 8
                                                       // xmm0 = v16_int8 = {0xa0, 0x0, 0xa0, 0x0, 0x8f, 0x0, 0x83, 0x0, 0x78, 0x0, 0x6d, 0x0, 0x61, 0x0, 0x61, 0x0}
(gdb) p /x $xmm0
$38 = {v4_float = {0x0, 0x0, 0x0, 0x0}, v2_double = {0x0, 0x0}, v16_int8 = {0xa0, 0x0, 0xa0, 0x0, 0x8f, 0x0, 0x83, 0x0, 0x78, 0x0, 0x6d, 0x0, 0x61, 0x0, 0x61, 0x0}, v8_int16 = {
    0xa0, 0xa0, 0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61}, v4_int32 = {0xa000a0, 0x83008f, 0x6d0078, 0x610061}, v2_int64 = {0x83008f00a000a0, 0x610061006d0078}, 
  uint128 = 0x610061006d00780083008f00a000a0}

      "packuswb   %%xmm0,%%xmm0                  \n"  // xmm0 = v16_int8 = {0xa0, 0xa0, 0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61, 0xa0, 0xa0, 0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61},
                                                                v8_int16 = {0xa0a0, 0x838f, 0x6d78, 0x6161, 0xa0a0, 0x838f, 0x6d78, 0x6161}
(gdb) p /x $xmm0
$40 = {v4_float = {0x0, 0xffffffff, 0x0, 0xffffffff}, v2_double = {0x7fffffffffffffff, 0x7fffffffffffffff}, v16_int8 = {0xa0, 0xa0, 0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61, 0xa0, 0xa0, 
    0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61}, v8_int16 = {0xa0a0, 0x838f, 0x6d78, 0x6161, 0xa0a0, 0x838f, 0x6d78, 0x6161}, v4_int32 = {0x838fa0a0, 0x61616d78, 0x838fa0a0, 0x61616d78}, 
  v2_int64 = {0x61616d78838fa0a0, 0x61616d78838fa0a0}, uint128 = 0x61616d78838fa0a061616d78838fa0a0}

      "movq       %%xmm0,(%3,%2,1)               \n"

(gdb) p /x dst
$47 = {0xa0, 0xa0, 0x8f, 0x83, 0x78, 0x6d, 0x61, 0x61}

      "lea        0x8(%2),%2                     \n" // Fixme
      "sub        $0x8,%4                        \n"
      "jg        1b                              \n"
      : "+r"(src0),   // %0
        "+r"(src1),   // %1
        "+r"(alpha),  // %2
        "+r"(dst),    // %3
        "+rm"(width)  // %4
        ::"memory",
        "cc", "eax", "xmm0", "xmm1", "xmm2", "xmm5", "xmm6", "xmm7");
}


// global blend 32 pixels at a time. width = n * 32 (n >=1)
// dst[i] = ((src0[i]*alpah[0])+(src1[i]*(255-alpha[0]))+255)/256
static void ff_global_blend_row_avx2(const uint8_t *src0,
                                     const uint8_t *src1,
                                     const uint8_t *alpha,
                                     uint8_t *dst,
                                     int width)
{
  __asm__ volatile(
      "vpcmpeqb   %%ymm5,%%ymm5,%%ymm5           \n"
      "vpsllw     $0x8,%%ymm5,%%ymm5             \n"
      "mov        $0x80808080,%%eax              \n" 
      "vmovd      %%eax,%%xmm6                   \n" xmm6 = 
      "vbroadcastss %%xmm6,%%ymm6                \n" xmm6 = v32_int8 = {0x80 <repeats 32 times>}
      "mov        $0x807f807f,%%eax              \n"
      "vmovd      %%eax,%%xmm7                   \n"
      "vbroadcastss %%xmm7,%%ymm7                \n"
      //"sub        %2,%0                          \n"
      //"sub        %2,%1                          \n"
      //"sub        %2,%3                          \n"

      // 32 pixel per loop.
      "1:                                        \n"
      "vmovdqu    (%2),%%ymm0                    \n" // Move unaligned packed integer values from ymm2/m256 to ymm1.
                                                     // v32_int8 = {0x55 <repeats 32 times>}, v16_int16 = {0x5555 <repeats 16 times>} load 32 byte
      "vpunpckhbw %%ymm0,%%ymm0,%%ymm3           \n"
      "vpunpcklbw %%ymm0,%%ymm0,%%ymm0           \n"
      "vpxor      %%ymm5,%%ymm3,%%ymm3           \n"
      "vpxor      %%ymm5,%%ymm0,%%ymm0           \n"

      "vmovdqu    (%0),%%ymm1                    \n"
      "vmovdqu    (%1),%%ymm2                    \n"
      "vpunpckhbw %%ymm2,%%ymm1,%%ymm4           \n"
      "vpunpcklbw %%ymm2,%%ymm1,%%ymm1           \n"
      "vpsubb     %%ymm6,%%ymm4,%%ymm4           \n"
      "vpsubb     %%ymm6,%%ymm1,%%ymm1           \n"
      "vpmaddubsw %%ymm4,%%ymm3,%%ymm3           \n"
      "vpmaddubsw %%ymm1,%%ymm0,%%ymm0           \n"
      "vpaddw     %%ymm7,%%ymm3,%%ymm3           \n"
      "vpaddw     %%ymm7,%%ymm0,%%ymm0           \n"
      "vpsrlw     $0x8,%%ymm3,%%ymm3             \n"
      "vpsrlw     $0x8,%%ymm0,%%ymm0             \n"
      "vpackuswb  %%ymm3,%%ymm0,%%ymm0           \n"

      "vmovdqu    %%ymm0,(%3)                    \n"
      "lea        0x20(%0),%0                    \n"
      "lea        0x20(%1),%1                    \n"
      "lea        0x20(%3),%3                    \n"
      "sub        $0x20,%4                       \n"
      "jg        1b                              \n"
      "vzeroupper                                \n"
      : "+r"(src0),   // %0
        "+r"(src1),   // %1
        "+r"(alpha),  // %2
        "+r"(dst),    // %3
        "+rm"(width)  // %4
        ::"memory",
        "cc", "eax", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6",
         "xmm7", "xmm8");
}

int  ff_pixelutils_sad16_NxM_mmxext( uint16_t *src1, intptr_t, uint16_t *src2, intptr_t )

0000000000000c60 <ff_pixelutils_sad16_16x16_mmxext>:
     c60:       0f ef c0                pxor   %mm0,%mm0
     c63:       41 b8 10 00 00 00       mov    $0x10,%r8d
     
     c69:       0f 6f 0f                movq   (%rdi),%mm1
     c6c:       0f 6f 57 08             movq   0x8(%rdi),%mm2
     c70:       0f 6f 5f 10             movq   0x10(%rdi),%mm3
     c74:       0f 6f 67 18             movq   0x18(%rdi),%mm4
     c78:       0f f9 0a                psubw  (%rdx),%mm1
     c7b:       0f f9 52 08             psubw  0x8(%rdx),%mm2
     c7f:       0f f9 5a 10             psubw  0x10(%rdx),%mm3
     c83:       0f f9 62 18             psubw  0x18(%rdx),%mm4
     c87:       0f ef ed                pxor   %mm5,%mm5
     c8a:       0f ef f6                pxor   %mm6,%mm6
     c8d:       0f f9 e9                psubw  %mm1,%mm5
     c90:       0f f9 f2                psubw  %mm2,%mm6
     c93:       0f ee cd                pmaxsw %mm5,%mm1
     c96:       0f ee d6                pmaxsw %mm6,%mm2
     c99:       0f ef ff                pxor   %mm7,%mm7
     c9c:       0f ef ed                pxor   %mm5,%mm5
     c9f:       0f f9 fb                psubw  %mm3,%mm7
     ca2:       0f f9 ec                psubw  %mm4,%mm5
     ca5:       0f ee df                pmaxsw %mm7,%mm3
     ca8:       0f ee e5                pmaxsw %mm5,%mm4
     cab:       48 8d 3c 77             lea    (%rdi,%rsi,2),%rdi
     caf:       48 8d 14 4a             lea    (%rdx,%rcx,2),%rdx
     cb3:       0f fd ca                paddw  %mm2,%mm1
     cb6:       0f fd dc                paddw  %mm4,%mm3
     cb9:       0f fd c1                paddw  %mm1,%mm0
     cbc:       0f fd c3                paddw  %mm3,%mm0
     cbf:       41 ff c8                dec    %r8d
     cc2:       7f a5                   jg     c69 <ff_pixelutils_sad16_16x16_mmxext+0x9>
     cc4:       0f 6f c8                movq   %mm0,%mm1
     cc7:       0f 72 d1 10             psrld  $0x10,%mm1
     ccb:       0f 72 f0 10             pslld  $0x10,%mm0
     ccf:       0f 72 d0 10             psrld  $0x10,%mm0
     cd3:       0f fe c1                paddd  %mm1,%mm0
     cd6:       0f 70 c8 0e             pshufw $0xe,%mm0,%mm1
     cda:       0f fe c1                paddd  %mm1,%mm0
     cdd:       0f 7e c0                movd   %mm0,%eax
